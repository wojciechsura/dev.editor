<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using Dev.Editor.BinAnalyzer.Data;
using Dev.Editor.BinAnalyzer.AnalyzerDefinition.Expressions;
using Dev.Editor.BinAnalyzer.Exceptions;
using Dev.Editor.Resources;
<#
    (string type, string name, string readerMethod)[] data = new (string type, string name, string readerMethod)[] 
    {
        ("byte", "Byte", "ReadByte"),
        ("sbyte", "Sbyte", "ReadSByte"),
        ("short", "Short", "ReadInt16"),
        ("ushort", "Ushort", "ReadUInt16"),
        ("int", "Int", "ReadInt32"),
        ("uint", "Uint", "ReadUInt32"),
        ("long", "Long", "ReadInt64"),
        ("ulong", "Ulong", "ReadUInt64"),
        ("float", "Float", "ReadSingle"),
        ("double", "Double", "ReadDouble")
    };  
#>

namespace Dev.Editor.BinAnalyzer.AnalyzerDefinition.Statements
{
<#    
foreach (var item in data)
{
#>
    class <#=item.name#>FieldStatement : BaseFieldStatement
    {
        public <#=item.name#>FieldStatement(int line, int column, string name)
            : base(line, column, name)
        {
            
        }

        internal override void Read(BinaryReader reader, List<BaseData> result, Scope scope)
        {
            try
            {
                if (reader.BaseStream.Position + sizeof(<#=item.type#>) >= reader.BaseStream.Length)
                    throw new AnalysisException(Line, Column, "Unexpected end of stream", Strings.Message_AnalysisError_UnexpectedEndOfStream);

                <#=item.type#> value = reader.<#=item.readerMethod#>();

                var data = new <#=item.name#>Data(name, value);
                result.Add(data);
                scope.AddContent(name, data);
            }
            catch (BaseLocalizedException e)
            {
                throw new AnalysisException(Line, Column, "Failed to load field!", string.Format(Strings.Message_AnalysisError_FailedToReadField, name, e.LocalizedErrorMessage));
            }
            catch (Exception e)
            {
                throw new AnalysisException(Line, Column, "Failed to load field!", string.Format(Strings.Message_AnalysisError_FailedToReadField, name, e.Message));
            }
        }
    }

<#
}

    foreach (var item in data)
    {
#>
    class <#=item.name#>ArrayFieldStatement : BaseFieldStatement
    {
        private readonly Expression count;

        public <#=item.name#>ArrayFieldStatement(int line, int column, string name, Expression count)
            : base(line, column, name)
        {
            this.count = count;
        }

        internal override void Read(BinaryReader reader, List<BaseData> result, Scope scope)
        {
            try
            {
                dynamic countValue = count.Eval(scope);
                int countInt = (int)countValue;
                
                if (reader.BaseStream.Position + sizeof(<#=item.type#>) * countInt >= reader.BaseStream.Length)
                    throw new AnalysisException(Line, Column, "Unexpected end of stream", Strings.Message_AnalysisError_UnexpectedEndOfStream);

                <#=item.name#>Data[] data = new <#=item.name#>Data[countInt];
                for (int i = 0; i < countInt; i++)
                {
                    <#=item.type#> value = reader.<#=item.readerMethod#>();
                    var element = new <#=item.name#>Data(i.ToString(), value);
                    data[i] = element;
                }

                ArrayData<<#=item.name#>Data> item = new ArrayData<<#=item.name#>Data>(name, "<#=item.name#>", data);

                result.Add(item);
                scope.AddContent(name, item);
            }
            catch (BaseLocalizedException e)
            {
                throw new AnalysisException(Line, Column, "Failed to load field!", string.Format(Strings.Message_AnalysisError_FailedToReadField, name, e.LocalizedErrorMessage));
            }
            catch (Exception e)
            {
                throw new AnalysisException(Line, Column, "Failed to load field!", string.Format(Strings.Message_AnalysisError_FailedToReadField, name, e.Message));
            }
        }
    }

<#
    }
#>
    class FieldFactory
    {
        public static BaseFieldStatement FromTypeName(int line, int column, string typeName, string name)
        {
            switch (typeName)
            {
<#
foreach (var item in data)
{
#>
                case "<#=item.type#>":
                    return new <#=item.name#>FieldStatement(line, column, name);
<#
}
#>
                case "skip":
                    return new SkipFieldStatement(line, column, name);
                case "char":
                    return new CharFieldStatement(line, column, name);
                default:
                    throw new InvalidEnumArgumentException("Unsupported type name!");
            }
        }
    }

    class ArrayFieldFactory
    {
        public static BaseFieldStatement FromTypeName(int line, int column, string typeName, string name, Expression count)
        {
            switch (typeName)
            {
<#
foreach (var item in data)
{
#>
                case "<#=item.type#>":
                    return new <#=item.name#>ArrayFieldStatement(line, column, name, count);
<#
}
#>
                case "skip":
                    return new SkipArrayFieldStatement(line, column, name, count);
                case "char":
                    return new CharArrayFieldStatement(line, column, name, count);
                default:
                    throw new InvalidEnumArgumentException("Unsupported type name!");
            }
        }
    }
}

namespace Dev.Editor.BinAnalyzer.Data
{
<#  
    foreach (var item in data)
    {
        var t = item.type;
        var n = item.name;
#>
    public class <#=n#>Data : BaseValueData
    {       
        private readonly <#=t#> value;

        public <#=n#>Data(string name, <#=t#> value)
            : base(name, "<#=t#>")
        {
            this.value = value;
        }

        public override dynamic GetValue()
        {
            return value;
        }
    }

<#
    }
#>

    public class DataFactory
    {
        public static BaseData DataFromDynamic(string name, dynamic d)
        {
            <#
            foreach (var item in data)
            {
                #>
if (d is <#=item.type#> <#=item.type#>Dynamic)
                return new <#=item.name#>Data(name, <#=item.type#>Dynamic);
            else <#
            }
#> if (d is string str)
                return new CharArrayData(name, str);
            else

                throw new InvalidOperationException("Unsupported type!");
        }
    }
}